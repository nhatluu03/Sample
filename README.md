<div class="description user_content enhanced"><p><strong>Course code and name:&nbsp;</strong>COSC2658 - Data Structures and Algorithms</p>
<p><strong>Assessment name:</strong> Test 1 (REAL)</p>
<p><strong>Length:</strong><span> 2 hours + 10 minutes for submission</span></p>
<p><strong>Type:</strong> Individual</p>
<p><strong>Feedback mode:</strong>&nbsp;Written feedback</p>
<p><strong>Late work: </strong>N/A</p>
<h2>Learning Objectives Assessed</h2>
<ul>
<li>CLO 2: Compare, contrast, and apply key data structures: trees, lists, stacks, queues, hash tables, and graph representations.</li>
<li>CLO 3: Define, compare, analyse, and solve general algorithmic problem types: sorting, searching, string processing, graphs, and geometric.</li>
<li>CLO 4: Compare, contrast, and apply algorithmic tradeoffs: time vs. space, deterministic vs. randomized, and exact vs. approximate.</li>
<li>CLO 5: Implement, empirically compare, and apply fundamental algorithms and data structures to real-world problems.</li>
</ul>
<h2>Ready for Life and Work</h2>
<p>Algorithm design and implementation are the heart of many software development tasks</p>
<p>Develop problem-formulation and problem-solving skills</p>
<hr>
<h2>Assessment Details</h2>
<h3>Instructions</h3>
<p><strong>Note: you must strictly follow the instructions below</strong></p>
<ul>
<li>Students will work individually on this assessment.</li>
<li>Students must ensure that their computers (personal or lab) have the necessary software themselves. The lecturer/invigilator will NOT provide any support regarding computer configuration or software installation/execution during exam time.</li>
<li><span>Students have to <strong>record their computer screens</strong> during the test and put the link to the recorded video in the comment section of students' Canvas submissions <strong>within 5 hours</strong> after the assessment deadline. Students must set the <strong>video permission</strong> to make it <strong>publicly accessible</strong>. </span><span>Submission without a video link or an inaccessible link is considered invalid and the total score can be deducted up to 50%.</span></li>
<li><span style="font-family: inherit; font-size: 1rem;">Students must use a <strong>single-screen computer</strong> during the assessment.</span></li>
<li>Students use Canvas to submit solutions.</li>
<li>Students can use the following resources during assessment time:
<ul>
<li>Physical resources (books, printed notes, hand-written notes)</li>
<li>Online resource: Course Canvas, Java documentation, and the course GitHub repository (No more)</li>
<li><a class="inline_disabled external" href="https://docs.oracle.com/javase/10/docs/api/overview-summary.html" target="_blank" rel="noreferrer noopener"><span>Link to Java Docs</span><span class="external_link_icon" style="margin-inline-start: 5px; display: inline-block; " role="presentation"><svg viewBox="0 0 1920 1920" xmlns="http://www.w3.org/2000/svg" style="width:1em; height:1em; vertical-align:middle; fill:currentColor">
    <path d="M1226.66667,267 C1314.88,267 1386.66667,338.786667 1386.66667,427 L1386.66667,427 L1386.66667,853.666667 L1280,853.666667 L1280,693.666667 L106.666667,693.666667 L106.666667,1493.66667 C106.666667,1523 130.56,1547 160,1547 L160,1547 L1226.66667,1547 C1256.10667,1547 1280,1523 1280,1493.66667 L1280,1493.66667 L1280,1280.33333 L1386.66667,1280.33333 L1386.66667,1493.66667 C1386.66667,1581.88 1314.88,1653.66667 1226.66667,1653.66667 L1226.66667,1653.66667 L160,1653.66667 C71.7866667,1653.66667 0,1581.88 0,1493.66667 L0,1493.66667 L0,427 C0,338.786667 71.7866667,267 160,267 L160,267 Z M1584.37333,709.293333 L1904.37333,1029.29333 C1925.17333,1050.09333 1925.17333,1083.90667 1904.37333,1104.70667 L1904.37333,1104.70667 L1584.37333,1424.70667 L1508.96,1349.29333 L1737.86667,1120.38667 L906.613333,1120.38667 L906.613333,1013.72 L1737.86667,1013.72 L1508.96,784.706667 L1584.37333,709.293333 Z M1226.66667,373.666667 L160,373.666667 C130.56,373.666667 106.666667,397.666667 106.666667,427 L106.666667,427 L106.666667,587 L1280,587 L1280,427 C1280,397.666667 1256.10667,373.666667 1226.66667,373.666667 L1226.66667,373.666667 Z" stroke="none" stroke-width="1" fill-rule="evenodd"></path>
</svg>
<span class="screenreader-only">Links to an external site.</span></span></a></li>
<li><a class="inline_disabled external" href="https://github.com/TriDang/cosc2658-2023-s1" target="_blank" rel="noreferrer noopener"><span>Link to the course GitHub</span><span class="external_link_icon" style="margin-inline-start: 5px; display: inline-block; " role="presentation"><svg viewBox="0 0 1920 1920" xmlns="http://www.w3.org/2000/svg" style="width:1em; height:1em; vertical-align:middle; fill:currentColor">
    <path d="M1226.66667,267 C1314.88,267 1386.66667,338.786667 1386.66667,427 L1386.66667,427 L1386.66667,853.666667 L1280,853.666667 L1280,693.666667 L106.666667,693.666667 L106.666667,1493.66667 C106.666667,1523 130.56,1547 160,1547 L160,1547 L1226.66667,1547 C1256.10667,1547 1280,1523 1280,1493.66667 L1280,1493.66667 L1280,1280.33333 L1386.66667,1280.33333 L1386.66667,1493.66667 C1386.66667,1581.88 1314.88,1653.66667 1226.66667,1653.66667 L1226.66667,1653.66667 L160,1653.66667 C71.7866667,1653.66667 0,1581.88 0,1493.66667 L0,1493.66667 L0,427 C0,338.786667 71.7866667,267 160,267 L160,267 Z M1584.37333,709.293333 L1904.37333,1029.29333 C1925.17333,1050.09333 1925.17333,1083.90667 1904.37333,1104.70667 L1904.37333,1104.70667 L1584.37333,1424.70667 L1508.96,1349.29333 L1737.86667,1120.38667 L906.613333,1120.38667 L906.613333,1013.72 L1737.86667,1013.72 L1508.96,784.706667 L1584.37333,709.293333 Z M1226.66667,373.666667 L160,373.666667 C130.56,373.666667 106.666667,397.666667 106.666667,427 L106.666667,427 L106.666667,587 L1280,587 L1280,427 C1280,397.666667 1256.10667,373.666667 1226.66667,373.666667 L1226.66667,373.666667 Z" stroke="none" stroke-width="1" fill-rule="evenodd"></path>
</svg>
<span class="screenreader-only">Links to an external site.</span></span></a></li>
</ul>
</li>
<li>No email/chat during the exam</li>
<li><strong>The Java Collections Framework cannot be used</strong>. The code shared on the course GitHub repo can be used.</li>
<li><strong>Work similarity will be checked. </strong>Students have to protect their work from being copied. If there are similar works,<strong> all involved students are treated the same way</strong></li>
<li><strong>Deliverables: exactly 2 Java files for problems 1 and 2; a plain text file for problem 3. Compress all files into a single .zip file (any name) and submit the zip file to Canvas.</strong></li>
</ul>
<h3>Assessment Problems</h3>
<h3>Problem 1</h3>
<p>You found<strong> one box</strong> that contains zero or more diamonds. Besides diamonds, that box may also contain smaller boxes as well. Similarly, smaller boxes can contain even smaller boxes and diamonds, and so on. A diamond is represented as an asterisk character *, while a box is represented as a pair of opening and closing square brackets []. Everything between a pair of brackets is considered inside the corresponding box.</p>
<p>Refer to the examples below for more information:</p>
<p>Example 1: [*] =&gt; there is one box, and it contains one diamond.</p>
<p>Example 2: [[*]] =&gt; there are two boxes. The outer box contains the inner box. The inner box contains a diamond.</p>
<p>Example 3: [**[**]*] =&gt; there are two boxes. The outer box contains the inner box and three diamonds. The inner box contains two diamonds.</p>
<p>Example 4: [[[*]**]*] =&gt; there are three boxes. The outermost box contains one box and one diamond. The middle box contains one box and two diamonds. The innermost box contains one diamond.</p>
<p>Example 5: []* =&gt; this is an invalid configuration because diamonds must be in some boxes.</p>
<p>Example 6: [[*] =&gt; this is an invalid configuration because the opening and closing brackets don't match.</p>
<p>Example 7: [**][*] =&gt; this is an invalid configuration because there must be <strong>one</strong> outermost box.</p>
<p>Create a new class DiamondBox. For this class, implement a constructor that accepts a String representing the boxes and diamonds as described above (let's call this String <strong>configuration</strong>). The <strong>configuration</strong> contains only three types of letters: an asterisk, an opening bracket, and a closing bracket. Except for the constructor, your class must support the following three public operations (feel free to add additional private operations as needed - but their scope has to be private). Furthermore, let's call N the number of letters representing boxes and diamonds. What are the big-Os of your three methods regarding N in the worst case? You must insert a comment before the method signature to describe the method's big-O. A sample template is given below</p>
<pre>// method1 complexity = O(N * lgN)<br>public void method1() {<br>  .........<br>}</pre>
<ul>
<li>boolean isValid(): return whether the String representing boxes and diamonds is valid or not.</li>
<li>int deepestLevel(): return the level of the box whose level is maximum. The level of the outermost box is 1. If box X contains box Y directly, the level of box Y = (level of box X + 1). In Example 1, the deepest level is 1. In Example 2, the deepest level is 2. In Example 4, the deepest level is 3. It's assumed that this method is called only if the <strong>configuration</strong> is valid.</li>
<li>int maxDiamonds(): return the maximum number of diamonds in a single box. It's assumed that this method is called only if the <strong>configuration</strong> is valid. In Example 3, this method returns 3. In Example 4, this method returns 2.</li>
</ul>
<p>Create a DiamondBox object and use it in the main method (client code). Your client code must call all the above 3 public methods one or more times.</p>
<p>Your code for this problem must be stored in a single file DiamondBox.java.</p>
<h3>Problem 2</h3>
<p>You are developing a program to manage the map of a city. The city consists of N junction points. As such, you use a 2D array (i.e., a matrix) J of N by N to model the map. If there is a direct link from junction x to junction y, J[x][y] = 1, otherwise, J[x][y] = 0. For all valid values of x, we have J[x][x] = 0. Below is an example map:</p>
<pre>J = [[0, 1, 1, 0],<br>     [0, 0, 0, 1],<br>     [0, 1, 0, 0],<br>     [0, 0, 1, 0]]</pre>
<p>In this map, there are 4 junction points. There is a direct link from junction 0 (zero-based index) to junction 1, and another direct link from junction 0 to junction 2. However, there is no direct link from junction 1 to junction 0.</p>
<p>Create a class <strong>JunctionMap </strong>to manage the map. For this class, implement a constructor that accepts a 2D array of integers representing the whole map. Except for the constructor, JunctionMap must support the following three public operations (feel free to add additional private operations as needed - but their scope has to be private). Furthermore, let's call N the number of junctions in your collection. What are the big-O of your three methods regarding N in the worst case? You must insert a comment before the method signature to describe the method's big-O. A sample template is given below</p>
<pre>// method1 complexity = O(N ^ 2)<br>public void method1() {<br>  .........<br>}</pre>
<ul>
<li>boolean hasOneWayStreet(): return true if the map given in the constructor contains at least a one-way street. A one-way street is a street where you can go directly from one end to another, but you cannot go in the opposite direction. Return false if there is no one-way street. With the above example, this method returns true (because you can go from junction 0 to junction 1, but not from junction 1 to junction 0).</li>
<li>boolean hasDeadEnd(): return true if the map contains at least one junction where you cannot go to any other junctions once you reach it. In other words, return true if there exists at least one junction which has no outgoing link. With the above example, this method returns false (because from junction 0, you can go to junction 1 and junction 2; from junction 1, you can go to junction 3; from junction 2, you can go to junction 1; from junction 3, you can go to junction 2).</li>
<li>String getShortestPath(int source, int destination): return a String representing the shortest path from a junction index <strong>source</strong> to another junction index <strong>destination</strong> (all are zero-based). Note that source != destination. The returned path must have this form "source_index -&gt; intermediate_index1 -&gt; intermediate_index2 ... -&gt; destination_index". It means the returned path starts from the source junction to an intermediate junction 1, to another intermediate junction 2, and so on, and finally reaches the destination junction. You can go from a junction index X to another junction index Y if and only if J[X][Y] = 1. If it is not possible to reach the destination from the source, return an empty String. With the above example, getPath(0, 1) will return "0 -&gt; 1" because you can go from 0 to 1 directly; getPath(0, 3) will return "0 -&gt; 1 -&gt; 3" because you have to go from 0 to 1 first (there is no direct link from 0 to 3), then you can go from 1 to 3. Calling getPath(1, 0) will return "" (empty) because you cannot reach 0 from 1. If there are two or more shortest paths, you can return any path.</li>
</ul>
<p>Create a JunctionMap object and use it in the main method (client code). Your client code must call all the above 3 public methods one or more times.</p>
<p>Your code for this problem must be stored in a single file JunctionMap.java.</p>
<h3><span class="s1">Problem 3</span></h3>
<p>You are developing a game. In this game, each player has an array of items. Each item contains a strength power integer. A strength power is not always a positive number, it can be a negative number as well. You want the game to extract a continuous part of the items array such that the total power strength of the extracted part is maximum.</p>
<p>Example: [1, -3, 4, 2, -1, 3, -2, 1]</p>
<p>The extracted part with a maximum total strength power is [4, 2, -1, 3] =&gt; total strength power is 8.</p>
<p>Note: the extracted part can be the whole array, and its minimum length is 1.</p>
<p>The following algorithm is used to solve the above problem:</p>
<pre>int maxStrengthPower(int[] items)<br>    N = length(items)<br>    maxStrength = -INFINITY<br>    for start = 0 to (N - 1)<br>        for stop = start to (N - 1)<br>            sum = 0<br>            for i = start to stop<br>                sum += items[i]<br>            if (sum &gt; maxStrength)<br>                maxStrength = sum<br>    return maxStrength</pre>
<p>What is the time complexity of the above algorithm? Provide your analysis.</p>
<p>Can you propose a better algorithm and analyze its time complexity?</p>
<h3>Support Resources</h3>
<p>This assessment requires that you meet RMIT's expectations for academic integrity. More information and advice on how to avoid plagiarism are available in the Getting Started module.</p>
<p>Open&nbsp;<a href="https://rmit.instructure.com/courses/118548/pages/how-to-succeed-in-data-structures-and-algorithms#fragment-2" data-api-endpoint="https://rmit.instructure.com/api/v1/courses/118548/pages/how-to-succeed-in-data-structures-and-algorithms%23fragment-2" data-api-returntype="Page">the academic integrity page</a>.</p>
<p>Additional library and learning resources are available to help with the assessment in this course</p>
<p>Link to&nbsp;<a title="Assignment Support" href="https://rmit.instructure.com/courses/118548/pages/assignment-support" data-api-endpoint="https://rmit.instructure.com/api/v1/courses/118548/pages/assignment-support" data-api-returntype="Page">Assignment Support</a>.</p>
<h3>Submission Instructions</h3>
<ul>
<li>Your source code should be placed and submitted as a single zip file on canvas</li>
</ul>
</div>
